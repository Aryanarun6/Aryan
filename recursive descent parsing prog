#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* ----- Lexer ----- */
typedef enum {
    TOK_ID, TOK_NUM,
    TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH,
    TOK_LPAREN, TOK_RPAREN,
    TOK_END, TOK_ERR
} TokenType;

typedef struct {
    TokenType type;
    char lexeme[128];
} Token;

static const char *src = NULL;
static size_t pos = 0;
static Token lookahead;

static void skip_ws() {
    while (src[pos] && isspace((unsigned char)src[pos])) pos++;
}

static Token next_token() {
    skip_ws();
    Token t = {TOK_ERR, {0}};
    char c = src[pos];

    if (c == '\0') { t.type = TOK_END; return t; }

    if (isalpha((unsigned char)c) || c == '_') {             // identifier
        size_t start = pos++;
        while (isalnum((unsigned char)src[pos]) || src[pos] == '_') pos++;
        size_t len = pos - start;
        if (len >= sizeof(t.lexeme)) len = sizeof(t.lexeme) - 1;
        memcpy(t.lexeme, src + start, len); t.lexeme[len] = '\0';
        t.type = TOK_ID; return t;
    }

    if (isdigit((unsigned char)c)) {                          // number
        size_t start = pos++;
        while (isdigit((unsigned char)src[pos])) pos++;
        // (optional) handle decimals:
        if (src[pos] == '.') {
            pos++;
            while (isdigit((unsigned char)src[pos])) pos++;
        }
        size_t len = pos - start;
        if (len >= sizeof(t.lexeme)) len = sizeof(t.lexeme) - 1;
        memcpy(t.lexeme, src + start, len); t.lexeme[len] = '\0';
        t.type = TOK_NUM; return t;
    }

    pos++;                                                    // single-char tokens
    switch (c) {
        case '+': t.type = TOK_PLUS;  return t;
        case '-': t.type = TOK_MINUS; return t;
        case '*': t.type = TOK_STAR;  return t;
        case '/': t.type = TOK_SLASH; return t;
        case '(': t.type = TOK_LPAREN;return t;
        case ')': t.type = TOK_RPAREN;return t;
        default:  t.type = TOK_ERR;   t.lexeme[0] = c; t.lexeme[1] = '\0'; return t;
    }
}

static void advance() { lookahead = next_token(); }

static void error(const char *msg) {
    fprintf(stderr, "Parse error: %s near '%s'\n",
            msg, lookahead.type == TOK_END ? "EOF" :
            (lookahead.lexeme[0] ? lookahead.lexeme :
             (lookahead.type==TOK_PLUS?"+":lookahead.type==TOK_MINUS?"-":
              lookahead.type==TOK_STAR?"*":lookahead.type==TOK_SLASH?"/":
              lookahead.type==TOK_LPAREN?"(":
              lookahead.type==TOK_RPAREN?")":"?")));
    exit(1);
}

static void expect(TokenType t) {
    if (lookahead.type == t) { advance(); }
    else { error("unexpected token"); }
}

/* ----- Parser (Recursive Descent) -----
   E  → T ((+|-) T)*
   T  → F ((*|/) F)*
   F  → ( E ) | id | num
*/
static void E(); static void T(); static void F();

static void E() {
    T();
    while (lookahead.type == TOK_PLUS || lookahead.type == TOK_MINUS) {
        advance(); // consume + or -
        T();
    }
}

static void T() {
    F();
    while (lookahead.type == TOK_STAR || lookahead.type == TOK_SLASH) {
        advance(); // consume * or /
        F();
    }
}

static void F() {
    if (lookahead.type == TOK_LPAREN) {
        advance();
        E();
        expect(TOK_RPAREN);
    } else if (lookahead.type == TOK_ID || lookahead.type == TOK_NUM) {
        advance();
    } else {
        error("expected identifier, number, or '('");
    }
}

/* ----- Driver ----- */
int main() {
    char line[1024];

    printf("Enter an expression (e.g., a+b*c or (x1+23)/y):\n");
    if (!fgets(line, sizeof(line), stdin)) {
        fprintf(stderr, "No input.\n");
        return 1;
    }
    // strip trailing newline
    line[strcspn(line, "\n")] = '\0';

    src = line; pos = 0;
    advance();      // initialize lookahead
    E();            // parse starting symbol

    if (lookahead.type == TOK_END) {
        printf("Input is VALID according to the grammar.\n");
        return 0;
    } else {
        error("extra input after valid expression");
        return 1;
    }
}
